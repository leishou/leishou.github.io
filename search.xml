<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2022数据库实习三</title>
      <link href="/2022/05/11/2022%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%B9%A0%E4%B8%89/"/>
      <url>/2022/05/11/2022%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%B9%A0%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据库实习三"><a href="#数据库实习三" class="headerlink" title="数据库实习三"></a>数据库实习三</h1><h3 id="1-插入点数据："><a href="#1-插入点数据：" class="headerlink" title="1.插入点数据："></a>1.插入点数据：</h3><h5 id="思路：原工程文件”MapEditorView-cpp”添加InsertData函数，并在OnLButtonUp函数中添加代码。"><a href="#思路：原工程文件”MapEditorView-cpp”添加InsertData函数，并在OnLButtonUp函数中添加代码。" class="headerlink" title="思路：原工程文件”MapEditorView.cpp”添加InsertData函数，并在OnLButtonUp函数中添加代码。"></a>思路：原工程文件”MapEditorView.cpp”添加InsertData函数，并在OnLButtonUp函数中添加代码。</h5><pre><code>static bool InsertData(SQLHDBC hdbc, int mFID, float mX, float mY, int mcolor, int mpattern) &#123;    SQLHSTMT hstmt = SQL_NULL_HSTMT;    // Allocate execute statement handle.    SQLRETURN ret = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp;hstmt);    if (!SQL_SUCCEEDED(ret)) &#123;        std::cout &lt;&lt; &quot;Failed to allocate execute statement handle!&quot; &lt;&lt; std::endl;        return false;    &#125;    SQLSMALLINT FID = 0;    SQLFLOAT X = 0;    SQLFLOAT Y = 0;    SQLSMALLINT color = 0;    SQLSMALLINT pattern = 0;    SQLWCHAR insert_sql[256] = L&quot;insert into PNT_Table(FID,X, Y,color, pattern) values(?,?,?,?,?)&quot;;    ret = SQLPrepare(hstmt, insert_sql, SQL_NTS);    if (ret != SQL_SUCCESS) &#123;        std::cout &lt;&lt; &quot;Failed to prepare sql!&quot; &lt;&lt; std::endl;    &#125;    ret = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_SHORT, SQL_SMALLINT, 0, 0, (void*)&amp;FID, 0, 0);    ret = SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_DOUBLE, SQL_FLOAT, 0, 0, (void*)&amp;X, 0, 0);    ret = SQLBindParameter(hstmt, 3, SQL_PARAM_INPUT, SQL_C_DOUBLE, SQL_FLOAT, 0, 0, (void*)&amp;Y, 0, 0);    ret = SQLBindParameter(hstmt, 4, SQL_PARAM_INPUT, SQL_C_SHORT, SQL_SMALLINT, 0, 0, (void*)&amp;color, 0, 0);    ret = SQLBindParameter(hstmt, 5, SQL_PARAM_INPUT, SQL_C_SHORT, SQL_SMALLINT, 0, 0, (void*)&amp;pattern, 0, 0);    FID = mFID;    X = mX;    Y = mY;    color = mcolor;    pattern = mpattern;    ret = SQLExecute(hstmt);    if (ret != SQL_SUCCESS) &#123;        std::cout &lt;&lt; &quot;Failed to execute sql!&quot; &lt;&lt; std::endl;    &#125;    else    &#123;        std::cout &lt;&lt; &quot;Inserted successfully!&quot; &lt;&lt; std::endl;    &#125;    ret = SQLFreeHandle(SQL_HANDLE_STMT, hstmt);    if (!SQL_SUCCEEDED(ret)) &#123;        std::cout &lt;&lt; &quot;Failed to release execute statement handle!&quot; &lt;&lt; std::endl;    &#125;    std::cout &lt;&lt; &quot;insert information: FID:&quot; &lt;&lt; mFID &lt;&lt; &quot;,横坐标:&quot; &lt;&lt; mX &lt;&lt; &quot;,纵坐标:&quot; &lt;&lt; mY &lt;&lt; &quot;,颜色号:&quot; &lt;&lt; mcolor &lt;&lt; &quot;, 图案编号:&quot; &lt;&lt; mpattern &lt;&lt; std::endl;    return true;&#125;</code></pre><h5 id="添加部分-注意：连接部分要放在switch语句前"><a href="#添加部分-注意：连接部分要放在switch语句前" class="headerlink" title="添加部分:(注意：连接部分要放在switch语句前)"></a>添加部分:(注意：连接部分要放在switch语句前)</h5><pre><code>SQLHENV henv = SQL_NULL_HENV;    SQLHDBC hdbc = SQL_NULL_HDBC;    // Allocate environment handle.    SQLRETURN ret = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &amp;henv);    if (!SQL_SUCCEEDED(ret)) &#123;        std::cout &lt;&lt; &quot;Failed to allocate environment handle!&quot; &lt;&lt; std::endl;        return ;    &#125;    // Set the ODBC version environment attribute.    ret = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);    if (!SQL_SUCCEEDED(ret)) &#123;        std::cout &lt;&lt; &quot;Failed to set the ODBC version environment attribute!&quot; &lt;&lt; std::endl;        return ;    &#125;    // Allocate connection handle.    ret = SQLAllocHandle(SQL_HANDLE_DBC, henv, &amp;hdbc);    if (!SQL_SUCCEEDED(ret)) &#123;        std::cout &lt;&lt; &quot;Failed to allocate connection handle!&quot; &lt;&lt; std::endl;        return ;    &#125;    // Connect the sqlserver.    // 使用字符串连接。    SQLWCHAR out_string[1024];    SQLSMALLINT out_len;    SQLWCHAR dsn[256] = L&quot;Driver=&#123;SQL Server&#125;;Server=(local);Database=cs;Uid=sa;Pwd=12345678;&quot;;    ret = SQLDriverConnect(hdbc, NULL, dsn, SQL_NTS, out_string, 1024, &amp;out_len, SQL_DRIVER_COMPLETE);;    InsertData(hdbc, i, point.x, point.y, point.color, point.pattern);</code></pre><h3 id="2-修改点数据：原工程文件”MapEditorView-cpp”添加UpdateDataSQL函数，并在OnLButtonUp函数中添加代码。"><a href="#2-修改点数据：原工程文件”MapEditorView-cpp”添加UpdateDataSQL函数，并在OnLButtonUp函数中添加代码。" class="headerlink" title="2.修改点数据：原工程文件”MapEditorView.cpp”添加UpdateDataSQL函数，并在OnLButtonUp函数中添加代码。"></a>2.修改点数据：原工程文件”MapEditorView.cpp”添加UpdateDataSQL函数，并在OnLButtonUp函数中添加代码。</h3><pre><code>static bool UpdateDataSQL(SQLHDBC hdbc, float oldX ,float oldY, float mX, float mY) &#123;    SQLHSTMT hstmt = SQL_NULL_HSTMT;    // Allocate execute statement handle.    SQLRETURN ret = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp;hstmt);    if (!SQL_SUCCEEDED(ret)) &#123;        std::cout &lt;&lt; &quot;Failed to allocate execute statement handle!&quot; &lt;&lt; std::endl;        return false;    &#125;    //t旧    SQLFLOAT tX = 0;    SQLFLOAT tY = 0;    SQLFLOAT X = 0;    SQLFLOAT Y = 0;    /*SQLWCHAR insert_sql[256] = L&quot;UPDATE PNT_Table SET X=9 ,Y =6 ,color=8 ,pattern=99 where FID = 3&quot;;*/    SQLWCHAR insert_sql[256] = L&quot;UPDATE PNT_Table SET X= ? ,Y = ?  where X= ? AND Y= ?&quot;;    ret = SQLPrepare(hstmt, insert_sql, SQL_NTS);    if (ret != SQL_SUCCESS) &#123;        std::cout &lt;&lt; &quot;Failed to prepare sql!&quot; &lt;&lt; std::endl;    &#125;    ret = SQLBindParameter(hstmt, 3, SQL_PARAM_INPUT, SQL_C_DOUBLE, SQL_FLOAT, 0, 0, (void*)&amp;tX, 0, 0);    ret = SQLBindParameter(hstmt, 4, SQL_PARAM_INPUT, SQL_C_DOUBLE, SQL_FLOAT, 0, 0, (void*)&amp;tY, 0, 0);    ret = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_DOUBLE, SQL_FLOAT, 0, 0, (void*)&amp;X, 0, 0);    ret = SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_DOUBLE, SQL_FLOAT, 0, 0, (void*)&amp;Y, 0, 0);    tX = oldX;    tY = oldY;    X = mX;    Y = mY;    ret = SQLExecute(hstmt);    if (ret != SQL_SUCCESS) &#123;        std::cout &lt;&lt; &quot;Failed to execute sql!&quot; &lt;&lt; std::endl;    &#125;    else    &#123;        std::cout &lt;&lt; &quot;Updated successfully!&quot; &lt;&lt; std::endl;    &#125;    // Release execute statement handle.    ret = SQLFreeHandle(SQL_HANDLE_STMT, hstmt);    if (!SQL_SUCCEEDED(ret)) &#123;        std::cout &lt;&lt; &quot;Failed to release execute statement handle!&quot; &lt;&lt; std::endl;    &#125;    return true;&#125;</code></pre><h5 id="添加代码："><a href="#添加代码：" class="headerlink" title="添加代码："></a>添加代码：</h5><pre><code>SQLHENV henv = SQL_NULL_HENV;                SQLHDBC hdbc = SQL_NULL_HDBC;                // Allocate environment handle.                SQLRETURN ret = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &amp;henv);                if (!SQL_SUCCEEDED(ret)) &#123;                    std::cout &lt;&lt; &quot;Failed to allocate environment handle!&quot; &lt;&lt; std::endl;                    return;                &#125;                // Set the ODBC version environment attribute.                ret = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);                if (!SQL_SUCCEEDED(ret)) &#123;                    std::cout &lt;&lt; &quot;Failed to set the ODBC version environment attribute!&quot; &lt;&lt; std::endl;                    return;                &#125;                // Allocate connection handle.                ret = SQLAllocHandle(SQL_HANDLE_DBC, henv, &amp;hdbc);                if (!SQL_SUCCEEDED(ret)) &#123;                    std::cout &lt;&lt; &quot;Failed to allocate connection handle!&quot; &lt;&lt; std::endl;                    return;                &#125;                // Connect the sqlserver.                // 使用字符串连接。                SQLWCHAR out_string[1024];                SQLSMALLINT out_len;                SQLWCHAR dsn[256] = L&quot;Driver=&#123;SQL Server&#125;;Server=(local);Database=cs;Uid=sa;Pwd=12345678;&quot;;                ret = SQLDriverConnect(hdbc, NULL, dsn, SQL_NTS, out_string, 1024, &amp;out_len, SQL_DRIVER_COMPLETE);                UpdateDataSQL(hdbc, pnt.x, pnt.y,point.x,point.y );</code></pre><h3 id="3-删除点数据：原工程文件”MapEditorView-cpp”添加DeleteData函数，并在OnLButtonUp函数中添加代码。"><a href="#3-删除点数据：原工程文件”MapEditorView-cpp”添加DeleteData函数，并在OnLButtonUp函数中添加代码。" class="headerlink" title="3.删除点数据：原工程文件”MapEditorView.cpp”添加DeleteData函数，并在OnLButtonUp函数中添加代码。"></a>3.删除点数据：原工程文件”MapEditorView.cpp”添加DeleteData函数，并在OnLButtonUp函数中添加代码。</h3><pre><code>static bool DeleteData(SQLHDBC hdbc, float mX,float mY) &#123;    SQLHSTMT hstmt = SQL_NULL_HSTMT;    // Allocate execute statement handle.    SQLRETURN ret = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp;hstmt);    if (!SQL_SUCCEEDED(ret)) &#123;        std::cout &lt;&lt; &quot;Failed to allocate execute statement handle!&quot; &lt;&lt; std::endl;        return false;    &#125;    /*SQLWCHAR insert_sql[256] = L&quot;    DELETE FROM PNT_Table WHERE FID = 2&quot;;    ret = SQLPrepare(hstmt, insert_sql, SQL_NTS);    if(ret==0)    std::cout &lt;&lt; &quot;Deleted successfully!&quot; &lt;&lt; std::endl;*/    SQLFLOAT  X= 0;;// 不能超过sqlserver中定义的varchar长度。    SQLFLOAT  Y = 0;    SQLWCHAR insert_sql[256] = L&quot;    DELETE FROM PNT_Table WHERE X = ? AND Y = ?;&quot;;    ret = SQLPrepare(hstmt, insert_sql, SQL_NTS);    if (ret != SQL_SUCCESS) &#123;        std::cout &lt;&lt; &quot;Failed to prepare sql!&quot; &lt;&lt; std::endl;    &#125;    ret = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_DOUBLE, SQL_FLOAT, 0, 0, (void*)&amp;X, 0, 0);    ret = SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_DOUBLE, SQL_FLOAT, 0, 0, (void*)&amp;Y, 0, 0);    //strcpy((char*)FID, DelFID);    /*FID = DelFID;*/    X = mX;    Y = mY;    ret = SQLExecute(hstmt);    if (ret != SQL_SUCCESS) &#123;        std::cout &lt;&lt; &quot;Failed to execute sql!&quot; &lt;&lt; std::endl;    &#125;    else    &#123;        std::cout &lt;&lt; &quot;Deleted successfully!&quot; &lt;&lt; std::endl;    &#125;    // Release execute statement handle.    ret = SQLFreeHandle(SQL_HANDLE_STMT, hstmt);    if (!SQL_SUCCEEDED(ret)) &#123;        std::cout &lt;&lt; &quot;Failed to release execute statement handle!&quot; &lt;&lt; std::endl;    &#125;    std::cout &lt;&lt; &quot;delete information: FID:&quot;  &lt;&lt; std::endl;    return true;&#125;</code></pre><h3 id="添加代码"><a href="#添加代码" class="headerlink" title="添加代码:"></a>添加代码:</h3><pre><code>//建立连接                SQLHENV henv = SQL_NULL_HENV;                SQLHDBC hdbc = SQL_NULL_HDBC;                // Allocate environment handle.                SQLRETURN ret = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &amp;henv);                if (!SQL_SUCCEEDED(ret)) &#123;                    std::cout &lt;&lt; &quot;Failed to allocate environment handle!&quot; &lt;&lt; std::endl;                    return;                &#125;                // Set the ODBC version environment attribute.                ret = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);                if (!SQL_SUCCEEDED(ret)) &#123;                    std::cout &lt;&lt; &quot;Failed to set the ODBC version environment attribute!&quot; &lt;&lt; std::endl;                    return;                &#125;                // Allocate connection handle.                ret = SQLAllocHandle(SQL_HANDLE_DBC, henv, &amp;hdbc);                if (!SQL_SUCCEEDED(ret)) &#123;                    std::cout &lt;&lt; &quot;Failed to allocate connection handle!&quot; &lt;&lt; std::endl;                    return;                &#125;                // Connect the sqlserver.                // 使用字符串连接。                SQLWCHAR out_string[1024];                SQLSMALLINT out_len;                SQLWCHAR dsn[256] = L&quot;Driver=&#123;SQL Server&#125;;Server=(local);Database=cs;Uid=sa;Pwd=12345678;&quot;;                ret = SQLDriverConnect(hdbc, NULL, dsn, SQL_NTS, out_string, 1024, &amp;out_len, SQL_DRIVER_COMPLETE);</code></pre><h3 id="4-得到点数据：原工程文件”MapEditorView-cpp”添加FindData函数，在修改点参数时调用查找鼠标点击位置最近的点ID"><a href="#4-得到点数据：原工程文件”MapEditorView-cpp”添加FindData函数，在修改点参数时调用查找鼠标点击位置最近的点ID" class="headerlink" title="4.得到点数据：原工程文件”MapEditorView.cpp”添加FindData函数，在修改点参数时调用查找鼠标点击位置最近的点ID"></a>4.得到点数据：原工程文件”MapEditorView.cpp”添加FindData函数，在修改点参数时调用查找鼠标点击位置最近的点ID</h3><pre><code>static int FindData(SQLHDBC hdbc,float mX,float mY) &#123;    SQLHSTMT hstmt = SQL_NULL_HSTMT;    // Allocate execute statement handle.    SQLRETURN ret = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp;hstmt);    if (!SQL_SUCCEEDED(ret)) &#123;        std::cout &lt;&lt; &quot;Failed to allocate execute statement handle!&quot; &lt;&lt; std::endl;        return false;    &#125;    SQLSMALLINT FID = 0;    SQLFLOAT X = 0;    SQLFLOAT Y = 0;        SQLWCHAR select_sql[256] = L&quot;select FID from PNT_Table WHERE X=? AND Y=?&quot;;    ret = SQLPrepare(hstmt, select_sql, SQL_NTS);    if (!SQL_SUCCEEDED(ret)) &#123;        std::cout &lt;&lt; &quot;Failed to query data!&quot; &lt;&lt; std::endl;    &#125;    /*SQLBindCol(hstmt, 1, SQL_C_SHORT, (void*)&amp;FID, sizeof(FID), NULL);    SQLBindCol(hstmt, 2, SQL_C_FLOAT, (void*)&amp;X, sizeof(X), NULL);    SQLBindCol(hstmt, 3, SQL_C_FLOAT, (void*)&amp;Y, sizeof(Y), NULL);*/    //ret = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_SHORT, SQL_SMALLINT, 0, 0, (void*)&amp;FID, 0, 0);    ret = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_DOUBLE, SQL_FLOAT, 0, 0, (void*)&amp;X, 0, 0);    ret = SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_DOUBLE, SQL_FLOAT, 0, 0, (void*)&amp;Y, 0, 0);    X = mX;    Y = mY;    // Release execute statement handle.    SQLBindCol(hstmt, 1, SQL_C_SHORT, (void*)&amp;FID, sizeof(FID), NULL);    ret = SQLExecute(hstmt);    while (SQLFetch(hstmt) != SQL_NO_DATA) &#123;        std::cout &lt;&lt; &quot;FID: &quot; &lt;&lt; FID;        return FID;    &#125;    return true;&#125;</code></pre><h3 id="5-查找点数据：原工程文件”MapEditorView-cpp”添加UpdataDataSQL2函数，在修改点参数时调用得到点数据ID的函数查找鼠标点击位置最近的点ID，将其作为参数传入，改变点模式和颜色（颜色因数据类型受限未成功，原理同理），并在OnLButtonUp函数中添加代码。"><a href="#5-查找点数据：原工程文件”MapEditorView-cpp”添加UpdataDataSQL2函数，在修改点参数时调用得到点数据ID的函数查找鼠标点击位置最近的点ID，将其作为参数传入，改变点模式和颜色（颜色因数据类型受限未成功，原理同理），并在OnLButtonUp函数中添加代码。" class="headerlink" title="5.查找点数据：原工程文件”MapEditorView.cpp”添加UpdataDataSQL2函数，在修改点参数时调用得到点数据ID的函数查找鼠标点击位置最近的点ID，将其作为参数传入，改变点模式和颜色（颜色因数据类型受限未成功，原理同理），并在OnLButtonUp函数中添加代码。"></a>5.查找点数据：原工程文件”MapEditorView.cpp”添加UpdataDataSQL2函数，在修改点参数时调用得到点数据ID的函数查找鼠标点击位置最近的点ID，将其作为参数传入，改变点模式和颜色（颜色因数据类型受限未成功，原理同理），并在OnLButtonUp函数中添加代码。</h3><pre><code>static bool UpdateDataSQL2(SQLHDBC hdbc, int mFID , int mcolor ,int mpattern) &#123;    SQLHSTMT hstmt = SQL_NULL_HSTMT;    // Allocate execute statement handle.    SQLRETURN ret = SQLAllocHandle(SQL_HANDLE_STMT, hdbc, &amp;hstmt);    if (!SQL_SUCCEEDED(ret)) &#123;        std::cout &lt;&lt; &quot;Failed to allocate execute statement handle!&quot; &lt;&lt; std::endl;        return false;    &#125;    //t旧    SQLSMALLINT FID = 0;    SQLSMALLINT color = 0;    SQLSMALLINT pattern = 0;    /*SQLWCHAR insert_sql[256] = L&quot;UPDATE PNT_Table SET X=9 ,Y =6 ,color=8 ,pattern=99 where FID = 3&quot;;*/    SQLWCHAR insert_sql[256] = L&quot;UPDATE PNT_Table SET color= ? ,pattern = ?  where FID= ?&quot;;    ret = SQLPrepare(hstmt, insert_sql, SQL_NTS);    if (ret != SQL_SUCCESS) &#123;        std::cout &lt;&lt; &quot;Failed to prepare sql!&quot; &lt;&lt; std::endl;    &#125;    ret = SQLBindParameter(hstmt, 3, SQL_PARAM_INPUT, SQL_C_SHORT, SQL_SMALLINT, 0, 0, (void*)&amp;FID, 0, 0);    ret = SQLBindParameter(hstmt, 1, SQL_PARAM_INPUT, SQL_C_SHORT, SQL_SMALLINT, 0, 0, (void*)&amp;color, 0, 0);    ret = SQLBindParameter(hstmt, 2, SQL_PARAM_INPUT, SQL_C_SHORT, SQL_FLOAT, 0, 0, (void*)&amp;pattern, 0, 0);    FID = mFID;    color = mcolor;    pattern = mpattern;    ret = SQLExecute(hstmt);    if (ret != SQL_SUCCESS) &#123;        std::cout &lt;&lt; &quot;Failed to execute sql!&quot; &lt;&lt; std::endl;    &#125;    else    &#123;        std::cout &lt;&lt; &quot;Updated successfully!&quot; &lt;&lt; std::endl;    &#125;    // Release execute statement handle.    ret = SQLFreeHandle(SQL_HANDLE_STMT, hstmt);    if (!SQL_SUCCEEDED(ret)) &#123;        std::cout &lt;&lt; &quot;Failed to release execute statement handle!&quot; &lt;&lt; std::endl;    &#125;    return true;&#125;</code></pre><h5 id="添加代码：-1"><a href="#添加代码：-1" class="headerlink" title="添加代码："></a>添加代码：</h5><pre><code>SQLHENV henv = SQL_NULL_HENV;                    SQLHDBC hdbc = SQL_NULL_HDBC;                    // Allocate environment handle.                    SQLRETURN ret = SQLAllocHandle(SQL_HANDLE_ENV, SQL_NULL_HANDLE, &amp;henv);                    if (!SQL_SUCCEEDED(ret)) &#123;                        std::cout &lt;&lt; &quot;Failed to allocate environment handle!&quot; &lt;&lt; std::endl;                        return;                    &#125;                    // Set the ODBC version environment attribute.                    ret = SQLSetEnvAttr(henv, SQL_ATTR_ODBC_VERSION, (void*)SQL_OV_ODBC3, 0);                    if (!SQL_SUCCEEDED(ret)) &#123;                        std::cout &lt;&lt; &quot;Failed to set the ODBC version environment attribute!&quot; &lt;&lt; std::endl;                        return;                    &#125;                    // Allocate connection handle.                    ret = SQLAllocHandle(SQL_HANDLE_DBC, henv, &amp;hdbc);                    if (!SQL_SUCCEEDED(ret)) &#123;                        std::cout &lt;&lt; &quot;Failed to allocate connection handle!&quot; &lt;&lt; std::endl;                        return;                    &#125;                    // Connect the sqlserver.                    // 使用字符串连接。                    SQLWCHAR out_string[1024];                    SQLSMALLINT out_len;                    SQLWCHAR dsn[256] = L&quot;Driver=&#123;SQL Server&#125;;Server=(local);Database=cs;Uid=sa;Pwd=12345678;&quot;;                    ret = SQLDriverConnect(hdbc, NULL, dsn, SQL_NTS, out_string, 1024, &amp;out_len, SQL_DRIVER_COMPLETE);;                    int tmpFID=FindData(hdbc, tempPoint.x, tempPoint.y);                    UpdateDataSQL2(hdbc, tmpFID, tempPoint.color, tempPoint.pattern);</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2022现代软件工程考题复现</title>
      <link href="/2022/05/10/2022%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%80%83%E9%A2%98%E5%A4%8D%E7%8E%B0/"/>
      <url>/2022/05/10/2022%E7%8E%B0%E4%BB%A3%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%80%83%E9%A2%98%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="2022现代软件工程考题复现"><a href="#2022现代软件工程考题复现" class="headerlink" title="2022现代软件工程考题复现"></a>2022现代软件工程考题复现</h1><h3 id="1-名词解释相关"><a href="#1-名词解释相关" class="headerlink" title="1.名词解释相关"></a>1.名词解释相关</h3><h5 id="软件的服从性？并举一个表现软件服从性的例子（日常生活）"><a href="#软件的服从性？并举一个表现软件服从性的例子（日常生活）" class="headerlink" title="软件的服从性？并举一个表现软件服从性的例子（日常生活）"></a>软件的服从性？并举一个表现软件服从性的例子（日常生活）</h5><pre><code>服从性（Conformity） 软件不能独立存在，它总是要运行在硬件上面，它要服从系统中其他组成部分的要求，它还要服从用户的要求、行业系统的要求（例如银行利率的变化）。</code></pre><h3 id="2-简答题相关"><a href="#2-简答题相关" class="headerlink" title="2.简答题相关"></a>2.简答题相关</h3><h5 id="软件工程师的思维误区，在实习过程中遇到的类似情况并说明"><a href="#软件工程师的思维误区，在实习过程中遇到的类似情况并说明" class="headerlink" title="软件工程师的思维误区，在实习过程中遇到的类似情况并说明"></a>软件工程师的思维误区，在实习过程中遇到的类似情况并说明</h5><pre><code>1.分析麻痹:篮球场上，有100%的把握再出手2.依赖链条过长: 不分主次，想解决所有问题 3.思维误区 – 过早优化4.过早泛化</code></pre><h5 id="三种代码复审的名称和目的"><a href="#三种代码复审的名称和目的" class="headerlink" title="三种代码复审的名称和目的"></a>三种代码复审的名称和目的</h5><pre><code>1.自我复审 (self review) 自己 vs. 自己 用同伴复审的标准来要求自己。不一定最有效，因为开发者对自己总是过于自信。如果能持之以恒，则对个人有很大好处2.同伴复审 (Peer Review) 复审者 vs. 开发者 简便易行3.团队复审 (Team Review) 团队 vs. 开发者 有比较严格的规定和流程，用于关键的代码，以及复审后不再更新的代码。覆盖率高——有很多双眼睛盯着程序。但是有可能效率不高（全体人员都要到会）</code></pre><h5 id="瀑布模型、生鱼片模型、螺旋模型概述"><a href="#瀑布模型、生鱼片模型、螺旋模型概述" class="headerlink" title="瀑布模型、生鱼片模型、螺旋模型概述"></a>瀑布模型、生鱼片模型、螺旋模型概述</h5><pre><code>1.瀑布模型：它反映了软件开发的串行的，连贯的步骤 每一步的结果都是可验证的 减少风险 给团队提供稳定的流程支持 产品定义非常稳定，正确性重要，每一步都要被验证 使用的技术非常成熟，团队成员对这些技术也非常熟悉 子团队在不同的地理位置，不可能做到频繁的交流2.生鱼片模型：解决各个步骤分离的缺点3.螺旋模型:在每一个版本都要衡量并控制风险 随着投入的增加和产品的运行，产品失败的风险在降低 需要高水平的管理团队 很难明确定义目标和稳定的里程碑</code></pre><h5 id="调研方法焦点小组和调查问卷的优缺点"><a href="#调研方法焦点小组和调查问卷的优缺点" class="headerlink" title="调研方法焦点小组和调查问卷的优缺点"></a>调研方法焦点小组和调查问卷的优缺点</h5><pre><code>焦点小组：找到一群目标用户的代表，加上项目的利益相关者来讨论用户想要什么，用户对软件的评价等等。弱点： 一群人在一起，往往大家会出于讨好其他人的心理来发表意见，避免不一致的意见或冲突。参与讨论的人士表达能力也会有差异，有可能会出现一些善于表达的人士控制讨论议程的倾向。 讨论者对于他们不熟悉的事物（例如全新的市场、颠覆式的创新）不能表达有价值的想法：—在汽车出现之前，我们找一帮马车夫来畅想“未来的交通工具”，他们未必会贡献很有价值的想法。 讨论者容易受到主持人有意或无意的影响。 研究者往往从不同意见中挑选最符合自己利益的那些条目，然后对外号称这就是大家的共识。以上这些特点要求会议的组织者要有很强的组织能力，能让不同角色都充分表达意见，并如实地总结这些意见。调查问卷：常见毛病 定义不明确， 使用含混的形容词 让用户花额外的努力来回答问题带有引导性的问题 过于开放式的问题 选择过于狭窄的问题</code></pre><h3 id="3-软件测试相关大题"><a href="#3-软件测试相关大题" class="headerlink" title="3.软件测试相关大题"></a>3.软件测试相关大题</h3><pre><code>根据题目情景划分有效等价类和无效等价类 有效集合 无效集合 以及生成最终测试用例PS:题目中是否选择同意协议也算作条件等价类划分-Example新浪邮箱1.  4~16个字符2.  支持英文小写、数字、下划线3.  不支持全部为数字或下划线输入条件    有效等价类             无效等价类用户名字符数    4~16(1)              0(2)、0&lt;个数&lt;4(3)、&gt;16(4)用户名组成    英文小写(5)、数字(6)、下划线(7)    非英文小写、数字、下划线(8)用户名支持格式    不全为数字(9)、不全为下划线(10)        全为数字(11)、全为下划线(12)生成最终测试用例：1    57huang_hzm    符合要求2    邮箱名为空        用户名字符数     3    hzm                不符合要求4    huzhaoming_1999_12_245    胡照名              用户名组成6    @#%……            7    HZM                不符合要求8    1234567890         用户名支持格式9    __________      不符合要求</code></pre><h3 id="4-分析燃尽图成因"><a href="#4-分析燃尽图成因" class="headerlink" title="4.分析燃尽图成因"></a>4.分析燃尽图成因</h3><pre><code>考试考的ppt里这一类：产品后期 “Resolved” 的工作项太多，来不及转移到 “关闭” 的状态。  可能的原因：    测试人员不够？    不能进行测试？</code></pre><h3 id="5-绘制-从代码完成到最终发布软件的流程图"><a href="#5-绘制-从代码完成到最终发布软件的流程图" class="headerlink" title="5.绘制 从代码完成到最终发布软件的流程图"></a>5.绘制 从代码完成到最终发布软件的流程图</h3><h3 id="6-UML大题根据一个产品完整的绘制用例图类图顺序图和部分活动图"><a href="#6-UML大题根据一个产品完整的绘制用例图类图顺序图和部分活动图" class="headerlink" title="6.UML大题根据一个产品完整的绘制用例图类图顺序图和部分活动图"></a>6.UML大题根据一个产品完整的绘制用例图类图顺序图和部分活动图</h3><pre><code>用例图使用 include extend 泛化关系类图 题目强调产品有软件、硬件之分 聚合组合关联关系 属性活动图 泳道顺序图  涉及对象的create destroy 循环 时间条件 激活区  控制流替代</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/10/%E4%B8%A4%E4%BD%8D%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
      <url>/2022/05/10/%E4%B8%A4%E4%BD%8D%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>两位工程师</p><p>崔工？</p><p>网络安全技术讲座</p><p>崔志强</p><p>挖坑挖的是数字货币</p><p><img src="C:\Users\15818\AppData\Roaming\Typora\typora-user-images\image-20220310140720942.png" alt="image-20220310140720942"></p><p>区块链</p><p><img src="C:\Users\15818\AppData\Roaming\Typora\typora-user-images\image-20220310141645876.png" alt="image-20220310141645876"></p><p>remove 删除 </p><p>劫持库文件</p><p>外联IP   进程</p><p>深夜挖坑 计划任务</p><p>1.查看资源占用率 查看外联IP</p><p>2.查看库文件是否被劫持</p><p>3.查看进程</p><p>4.查看计划任务和开机启动项目</p><p>客户确认  漏洞补丁 更新 </p><p>建议：接触挖坑，不提倡挖矿，有利益 比较可耻  不提倡</p><p>症状   如何    病毒分析</p><p>个人CPU  比较高级的显卡 专用设备 能量 电力  挖矿 虚拟货币    </p><p>投入收益比  国家对挖矿行为的治理  发现一例 清除一例</p><p>太阳光 猎户座</p><p>张艳明</p><p>资源消耗 金融体系影响</p><p>奖励  挖币 困难</p><p> 负收益  交易额度  炒作交易  马斯克 特斯拉</p><p>协议分析  库</p><p>代理访问 代理流量 提出问题</p><p>看代理位置 要经过我们才可以 境外代理 暗网</p><p>可以规避溯源  </p><p>威胁情报库会做标记</p><p>国家层面的国家威胁情报库</p><p>工信部 公共平台</p><p>第一次</p><p>主要内容</p><pre><code>挖矿病毒分析与防御  崔志强 网御星云高级渗透测试工程师1.了解挖矿2.挖矿病毒的产生3.挖矿病毒造成的影响4.挖矿病毒的应急手段挖矿行为发现&amp;治理解决方案 张艳明虚拟货币是什么挖矿收益和支出相关国家政策（严令禁止）如何查询挖矿主机挖矿排查方法挖矿行为阻断</code></pre><pre><code>心得体会：在此次网络安全技术讲座中学到许多，对“挖矿”一词有了更深入的了解。崔工首先为我们介绍了“挖矿”的相关内容，重点介绍了处理挖矿病毒的应急手段，主要有以下四点：1.查看资源占用率以及查看外联IP2.查看库文件是否被劫持3.查看进程4.查看计划任务和开机启动项目。其中Linux系统相关指令刚好是我们本学期操作系统课程的学习内容。张工介绍挖矿行为发现&amp;治理解决方案中为我们讲述了更多有关挖矿收益和产出的相关情况，国家对这一类的“虚拟货币”的重拳出击。随后张工就研究内容及研究方向为我们介绍了两大挖矿排查方法：DPI排查和威胁情报排查。在后续的交流互动环节，l</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/08/%E4%B8%80%EF%BC%9A%E7%BB%84%E9%98%9F/"/>
      <url>/2022/05/08/%E4%B8%80%EF%BC%9A%E7%BB%84%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一：组队</p><p>二：立项（现实）</p><p> 大学生时间管理系统</p><p>ME:参照番茄To do  Qt  感觉如果图框 规划设计好的 </p><pre><code>本地web服务框架https://github.com/ChattyKu/tomatoClockSimple</code></pre><p>存本地数据还是得用数据库相关得</p><p>是否要搞一个登录</p><p>一个母窗口 一个子窗口那样   </p><p>就控件管理  找例子</p><p>日历软件</p><p>辅助管理</p><p>创建事件   事件到期提醒</p><p>to do列表</p><p>迭代1  需求 规划发布   周期</p><p>需求描述尽量详细  测试用例  有模板 处理人 一周需求划分子需求  优先级 </p><p>需求  评论</p><p> 划分子需求</p><p>缺陷  测试</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/08/111202%20%E4%B8%BB%E9%A2%98%E7%8F%AD%E4%BC%9A/"/>
      <url>/2022/05/08/111202%20%E4%B8%BB%E9%A2%98%E7%8F%AD%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>111202 主题班会</p><p>探寻心中热爱，规划未来蓝图-寻找生命的意义 </p><p>15页</p><p>一页 目录</p><p>一页    开场视频  攻击性不要强</p><p>一页  一页分析视频内容 </p><p>考试时间表    大学生活将近过了一半</p><p>问问同学互动环节</p><p>然后游戏环节 </p><p>两个游戏</p><p>体验班委  目前想到的找错×</p><p>▲剧本杀的形式：</p><p>例子：学委收作业改备注  </p><p>分享环节</p><p>①新同学可以说说为什么想来软工</p><p>②喜欢读书的同学可以分享分享自己的书单</p><p>③征集班级同学兴趣爱好照片</p><p>总结环节</p><p>①总结班会内容</p><p>②延申祝福</p><p>蟹蟹观看(xiexie用图片jpg)</p><p>生涯规划课程</p><p>先谈兴趣 </p><p>后谈职业</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/08/0322%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/05/08/0322%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code>account(account_number, brach_name, balance)depositer(customer_name, account_number)</code></pre><p>建表 创建触发器</p><p>插入时加入记录</p><pre><code>create trigger csafter insert or update on accountreferencing new row as neowfor each rowas beginif </code></pre><p>173页</p><p>176页</p><pre><code>create table classroom    (building        varchar(15),     room_number        varchar(7),     capacity        numeric(4,0),     primary key (building, room_number)    );create table department    (dept_name        varchar(20),      building        varchar(15),      budget                numeric(12,2) check (budget &gt; 0),     primary key (dept_name)    );</code></pre><pre><code>create table dept(name  varchar(5),age   varchar(5),dept_work   varchar(7),salary       numeric(4,0),per_num      varchar(7),dept_num    varchar(7), primary key (per_num) ) 两者之间需要外键相连</code></pre><pre><code>create table dept(deptno  numeric(2),deptname   varchar(10),manager    varchar(10),phonenumber char(12),constraint PK_SC RIMARY key(deptno)); create table emp ( empno numeric(4), ename varchar(10), age    numeric(2), constraint c1 check (age&lt;=60), job varchar(9), salary numeric(7,2), deptno numeric(2), foreign key (deptno) references dept(deptno) );</code></pre><pre><code>6.grant all PRIVILEGES  on table student, class to U1grant all PRIVILEGES  on  student, class to U1 with grant optiongrant update(address),select on table student to U2grant select,update(address),delete on student to U2;grant select  on table class to publicgrant select on class to publicgrant update,select on table student to R1grant select ,update onstudent to R1grant update,select on table student to U1 with grant optiongrant R1 tO U1 with admin option</code></pre><pre><code>7.grant select on table dept,emp to WMtable shangrant insert,delete on table dept,emp to LYtable shangrant select on table c.emp to c    ?grant select on emp when user()=name  to all grant update(salary),select on table dept to LXtable shangrant all privileges on table dept,emp to ZX    修改结构//整体应该基于视图grant alter table on emp,dept to ZXgrant all privileges on emp,dept to 周平 with grant optioncreate view CSas select *from (select avg())create view dept_salary asselect dept,emo,max(salary),min(salary),avg(salary)from dept,empwhere dept.deptno=emp.deptnogroup by emp.deptnogrant select on dept_salary to YL</code></pre><pre><code>create table student(stu_num  numer)</code></pre><pre><code>class Solution &#123;public:    int combinationSum4(vector&lt;int&gt;&amp; nums, int target) &#123;        vector&lt;int&gt; dp(target + 1, 0);        dp[0] = 1;        for (int i = 0; i &lt;= target; i++) &#123; // 遍历背包            for (int j = 0; j &lt; nums.size(); j++) &#123; // 遍历物品                if (i - nums[j] &gt;= 0 &amp;&amp; dp[i] &lt; INT_MAX - dp[i - nums[j]]) &#123;                    dp[i] += dp[i - nums[j]];                &#125;            &#125;        &#125;        return dp[target];    &#125;&#125;;</code></pre><pre><code>//外循环target   内循环nums    int n=nums.size();    vector&lt;vector&lt;int&gt;&gt;dp(n,vector&lt;int&gt;(target+1,0));    for(int i=1;i&lt;=target;i++)    &#123;        for(int j=0;j&lt;n;j++)        &#123;            if(i&lt;=nums[j])            dp[i][j]=        &#125;    &#125;</code></pre><pre><code>dp[i] &lt; INT_MAX - dp[i - nums[j]]dp[i]+dp[i-nums[j]]&lt;INT_</code></pre><pre><code>account(account_number, brach_name, balance)depositer(customer_name, account_number)</code></pre><pre><code>create trigger cs after delete on accountreferencing old row as orowfor each rowbegindelete from depositerwhere depositer.customer_name not in(select customer_name from depositerwhere account_number!=orow.account_number)end</code></pre><pre><code>create table     branch_cust(brachname,customername)( brachname varchar(9),customername </code></pre><pre><code>CREATE TRIGGER delete_accountON accountafter deleteas DELETE FROM depositerWHERE exists(select account_number                from account            where account.account_number=depositer.account_number)</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/05/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code>#include &quot;pch.h&quot;#include &lt;iostream&gt;#include &lt;Windows.h&gt;#include &lt;process.h&gt;#include &lt;time.h&gt;using namespace std;#define N 10#define producer_size 3#define consumer_size 2HANDLE producer_thread[producer_size];HANDLE consumer_thread[consumer_size];//线程IDUINT producer_ID[producer_size];UINT consumer_ID[consumer_size];HANDLE Mymutex, Myfull, Myempty;int buffer[N];int in = 0, out = 0, item = 0;bool run = true;void insert_item(int item) &#123;    buffer[in] = item;    cout &lt;&lt; &quot;produce &quot; &lt;&lt; item &lt;&lt; &quot; in buffer &quot; &lt;&lt; in &lt;&lt; endl;    in = (in + 1) % N;&#125;void remove_item() &#123;    cout &lt;&lt; &quot;consume &quot; &lt;&lt; buffer[out] &lt;&lt; &quot; in buffer &quot; &lt;&lt; out &lt;&lt; endl;    out = (out + 1) % N;&#125;int produce_item() &#123;    return rand() % 100;&#125;unsigned __stdcall producer(HANDLE) &#123;    //int item;    while (run)    &#123;        //item = produce_item();        item = item + 1;        WaitForSingleObject(Myempty, INFINITE);        WaitForSingleObject(Mymutex, INFINITE);        insert_item(item);        Sleep(500);        ReleaseMutex(Mymutex);        ReleaseSemaphore(Myfull, 1, NULL);    &#125;    return 0;&#125;unsigned __stdcall consumer(HANDLE) &#123;    while (run)    &#123;        WaitForSingleObject(Myfull, INFINITE);        WaitForSingleObject(Mymutex, INFINITE);        remove_item();        Sleep(500);        ReleaseMutex(Mymutex);        ReleaseSemaphore(Myempty, 1, NULL);    &#125;    return 0;&#125;int main()&#123;    Mymutex = CreateMutex(NULL, false, NULL);//bInitialOwner BOOL，如创建进程希望立即拥有互斥体，则设为TRUE。一个互斥体同时只能由一个线程拥有    Myfull = CreateSemaphore(NULL, 0, N, NULL);    Myempty = CreateSemaphore(NULL, N, N, NULL);    for (int i = 0; i &lt; producer_size; i++) &#123;        producer_thread[i]=(HANDLE)_beginthreadex(NULL, 0, producer, NULL, 0, &amp;producer_ID[i]);        cout &lt;&lt; &quot;create producer &quot; &lt;&lt; i &lt;&lt; endl;    &#125;    for (int  i = 0; i &lt; consumer_size; i++)    &#123;        consumer_thread[i]=(HANDLE)_beginthreadex(NULL, 0, consumer, NULL, 0, &amp;consumer_ID[i]);        cout  &lt;&lt; &quot;create consumer &quot; &lt;&lt; i &lt;&lt; endl;    &#125;    /*主线程等待子线程结束*/    //for (int i = 0; i &lt; producer_size; i++) &#123;    //    WaitForSingleObject(producer_thread[i], INFINITE);    //    CloseHandle(producer_thread[i]);    //&#125;    //for (int i = 0; i &lt; consumer_size; i++)    //&#123;    //    WaitForSingleObject(consumer_thread[i], INFINITE);    //    CloseHandle(consumer_thread[i]);    //&#125;    if (getchar()) &#123;        run = false;    &#125;    return 0;&#125; 2022 GitHub, Inc.TermsPrivacySecurityStatusDocsContact GitHubPricingAPITrainingBlogAbout</code></pre><pre><code>//#include&lt;iostream&gt;//#include&lt;windows.h&gt;//#include&lt;process.h&gt;//#include &lt;QApplication&gt;//const int m_Max=10;//int Buffer=5 ;// bool run =false;//HANDLE m_mutex;//互斥信号量//HANDLE m_full;//满缓冲区//HANDLE m_empty;//空缓冲区//int buffer[m_Max];//缓冲区//int in=0;//int out=0;//int item=1;//#define producer_size 3//生产者进程个数//#define  consumer_size 2//消费者进程个数//using namespace std;//   HANDLE producer_thread[producer_size];//生产者进程//   HANDLE consumer_thread[consumer_size];//消费者进程//   UINT producer_ID[producer_size];//   UINT consumer_ID[consumer_size];//   void insert_item(int item)//  &#123;//      buffer[in]=item;//      cout&lt;&lt;&quot;produce&quot;&lt;&lt;item&lt;&lt;&quot;in buffer&quot;&lt;&lt;in&lt;&lt;endl;//      in=(in+1)%m_Max;//  &#125;//   void remove_item() &#123;//       cout &lt;&lt; &quot;consume &quot; &lt;&lt; buffer[out] &lt;&lt; &quot; in buffer &quot; &lt;&lt; out &lt;&lt; endl;//       out = (out + 1) % m_Max;//   &#125;//   int produce_item() &#123;//       return rand() % 100;//   &#125;//unsigned __stdcall producer(HANDLE)//&#123;//   while(run)//   &#123;//       item=item+1;//       WaitForSingleObject(m_empty,INFINITE);//P&amp;empty  //等待缓冲区中有数据//       WaitForSingleObject(m_mutex,INFINITE);//P&amp;  //等待缓冲区中有数据//       insert_item(item);//       Sleep(500);//       ReleaseMutex(m_mutex);//V&amp;mutex//       ReleaseSemaphore(m_full,1,NULL);//   &#125;//   return 0;//&#125;//unsigned __stdcall consumer(HANDLE) &#123;//    while (run)//    &#123;//        WaitForSingleObject(m_full, INFINITE);//        WaitForSingleObject(m_mutex, INFINITE);//        remove_item();//        Sleep(500);//        ReleaseMutex(m_mutex);//        ReleaseSemaphore(m_empty, 1, NULL);//    &#125;//    return 0;//&#125;</code></pre><pre><code>//int main(int argc, char *argv[])//&#123;//    QApplication a(argc, argv);//    MainWindow w;//    w.show();//    return a.exec();//&#125;//    m_mutex =CreateMutex(NULL,false,NULL);//初始化mutex   互斥体一个互斥体只能由一个线程拥有//    m_full =CreateSemaphore(NULL,0,m_Max,NULL);//    m_empty=CreateSemaphore(NULL,m_Max,m_Max,NULL);//    for(int i=0;i&lt;producer_size;i++)//    &#123;//        producer_thread[i]=(HANDLE)_beginthreadex(NULL,0,producer,NULL,0,&amp;producer_ID[i]);//        cout&lt;&lt;&quot;create producer &quot;&lt;&lt;i&lt;&lt;endl;//    &#125;//    for(int i=0;i&lt;consumer_size;i++)//    &#123;//        consumer_thread[i]=(HANDLE)_beginthreadex(NULL,0,consumer,NULL,0,&amp;producer_ID[i]);//        cout&lt;&lt;&quot;create consumer &quot;&lt;&lt;i&lt;&lt;endl;//    &#125;//    if(getchar())&#123;//        run=false;//    &#125;//    CloseHandle(m_mutex);//    CloseHandle(m_empty);//    CloseHandle(m_full);//&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/08/%E7%8F%AD%E4%BC%9A/"/>
      <url>/2022/05/08/%E7%8F%AD%E4%BC%9A/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>时间都去哪了</p><p>1.某学生摸鱼视频引入(热场)</p><p>2.班级同学时间变化图片</p><p>3.时间管理 四象限法</p><p>4.限时coding</p><p>5.1min 等待</p><p>6.看看1min内能做到什么</p><p>7.我给事情排个序</p><p>8.1min能改变什么？</p><p>差1min的步道乐跑</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/08/%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/08/%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>总评：没有达到预期</p><p>不足的：五一劳动节前每周能按时写作英语作文，之后不了了之。高数大物能完成预习任务，课后复习不够。大物重视不够，缺乏足够练习。面向对象课设期间没有及时Debug，在后期调试环节面临巨大挑战。</p><p>做的好的：背单词的预期目标完成，之前购买的四级考试真题完成。艺媒学院活动期间，坚持早起打卡和早锻炼，身体素质进一步提高。有学习QT尝试做了小案例，考前高数复习相较于上学期更为切实。提前尝试计组课设积累Debug经验，两门课设过程中记录了遇到的bug。</p><pre><code>cugj</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/08/%E4%BB%8A%E6%97%A5%E8%93%9D%E6%A1%A5/"/>
      <url>/2022/05/08/%E4%BB%8A%E6%97%A5%E8%93%9D%E6%A1%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今日蓝桥</p><p>1.子串分值和</p><pre><code>#include&lt;iostream&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int N=10010;char s[N];int dp[N];int ptr[30];int main()&#123;    cin&gt;&gt;s+1;    long long ans=0;    int len=strlen(s+1);    for(int i=1;i&lt;=len;i++)    &#123;        int t=s[i]-&#39;a&#39;;        dp[i]=dp[i-1]+i-ptr[t];        ptr[t]=i;        ans+=dp[i];    &#125;    cout&lt;&lt;ans;    return 0;&#125;</code></pre><p>上有问题 </p><p>卡片</p><pre><code>#include&lt;iostream&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int N=10;int a[N];int main()&#123;    for(int i=0;i&lt;10;i++)    a[i]=2021;        int cnt=1;    while(true)    &#123;        int x=cnt;        while(x)        &#123;            if(a[x%10]&gt;0)            a[x%10]--;            else            &#123;                cout&lt;&lt;cnt-1&lt;&lt;endl;                return 0;            &#125;            x/=10;        &#125;        cnt++;    &#125;    return 0;&#125;</code></pre><p>直线</p><pre><code>#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;utility&gt;using namespace std;const int X=20,Y=21;int main()&#123;    vector&lt;pair&lt;int,int&gt; &gt;vec;    for(int i=0;i&lt;X;i++)    for(int j=0;j&lt;Y;j++)    vec.push_back(&#123;i,j&#125;);        map&lt;pair&lt;double,double&gt;,bool&gt;ma;    for(int i=0;i&lt;vec.size();i++)    for(int j=i+1;j&lt;vec.size();j++)    &#123;                int x1=vec[i].first,x2=vec[j].first;        int y1=vec[i].second,y2=vec[j].second;        if(x1!=x2&amp;&amp;y1!=y2)&#123;            double k,b;            k= double(y2-y1)/(x2-x1);            b=double(x1*y2-x2*y1)/(x1-x2);            ma[&#123;k,b&#125;]=true;        &#125;    &#125;    cout&lt;&lt;ma.size()+X+Y&lt;&lt;endl;    return 0; &#125; </code></pre><p>货物摆放</p><pre><code>#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;typedef long long LL;const LL NUM=2021041820210418;int main()&#123;vector&lt;LL&gt;vec;for(LL i=1;i&lt;=NUM/i;i++)if(NUM%i==0)&#123;    vec.push_back(i);    if(i!=NUM/i)vec.push_back(NUM/i);&#125;LL ans=0;for(LL i=0;i&lt;vec.size();i++)for(LL j=0;j&lt;vec.size();j++)for(LL k=0;k&lt;vec.size();k++)if(vec[i]*vec[j]*vec[k]==NUM)ans++;cout&lt;&lt;ans&lt;&lt;endl;    return 0; &#125; </code></pre><pre><code>int gcd(int a, int b)&#123;return b?gcd(b,a%b):a;&#125;int stimes(int a ,int b)&#123;return a*b/gcd(a,b);&#125;</code></pre><p>路径 dijkstra()</p><pre><code>#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;using namespace std;int gcd(int a,int b)&#123;    return b?gcd(b,a%b):a;&#125;int stimes(int a,int b)&#123;    return a*b/gcd(a,b);&#125;const int N=2022,M=22;int g[N][N],dist[N];bool st[N];void dijkstra()&#123;    dist[1]=0;    for(int i=1;i&lt;N;i++)    &#123;        int t=-1;    for(int j=1;j&lt;N;j++)    if(!st[j]&amp;&amp;(t==-1||dist[j]&lt;dist[t]))    t=j;    st[t]=true;        for(int j=1;j&lt;N;j++)    dist[j]=min(dist[j],dist[t]+g[t][j]);&#125;&#125;int main()&#123;    memset(dist,0x3f,sizeof dist);    memset(g,0x3f,sizeof g);        for(int i=1;i&lt;N;i++)    for(int j=i+1;j&lt;N&amp;&amp;j-i&lt;M;j++)    g[i][j]=g[j][i]=stimes(i,j);        dijkstra();        cout&lt;&lt;dist[2021]&lt;&lt;endl;    return 0;&#125;</code></pre><p>回路计数</p><pre><code>#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;using namespace std;const int N=22,M=1&lt;&lt;N;int gcd(int a,int b)&#123;    return b?gcd(b,a%b):a;&#125;bool g[N][N];long long f[M][N];int main()&#123;    for(int i=1;i&lt;N;i++)    for(int j=1;j&lt;N;j++)    if(gcd(i,j)==1)    g[i][j]=true;        f[2][1]=1;    for(int i=1;i&lt;=M-2;i++)//遍历     for(int j=1;j&lt;N;j++)//到达的点     if(i&gt;&gt;j&amp;1)    for(int k=1;k&lt;N;k++)    if(g[k][j]&amp;&amp;i-(1&lt;&lt;j)&gt;&gt;k&amp;1)     f[i][j]+=f[i-(1&lt;&lt;j)][k];        long long ans=0;    for(int i=1;i&lt;N;i++)    ans+=f[M-2][i];        cout&lt;&lt;ans&lt;&lt;endl;        return 0;&#125;</code></pre><p>砝码称重</p><pre><code>#include&lt;iostream&gt;#include&lt;bits/stdc++.h&gt;using namespace std;int dp[105][100000];int n,w[105],sum,ans;int main()&#123;cin&gt;&gt;n;for(int i=1;i&lt;=n;i++)&#123;cin&gt;&gt;w[i];sum+=w[i];&#125;dp[0][0]=1;for(int i=1;i&lt;=n;i++)&#123;for(int j=0;j&lt;=sum;j++)&#123;dp[i][j]=max(dp[i-1][j],max(dp[i-1][j+w[i]],dp[i-1][abs(j-w[i])]));&#125;&#125;for(int i=1;i&lt;=sum;i++)&#123;if(dp[n][i])ans++;&#125;cout&lt;&lt;ans;return 0;&#125;</code></pre><p>左孩子 右兄弟</p><pre><code>#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;using namespace std;const int maxn=10052;int fa[maxn],n;vector&lt;int&gt;u[maxn];int dfs(int x)&#123;    int ret=1;        for(int i=0;i&lt;u[x].size();i++)    &#123;        int temp =1+dfs(u[x][i])+u[x].size()-1;        ret =max(temp,ret);    &#125;    return ret;&#125;int main()&#123;    cin&gt;&gt;n;    for(int i=0;i&lt;n-1;i++)    &#123;        cin&gt;&gt;fa[i];        u[fa[i]].push_back(i+2);    &#125;    cout&lt;&lt;dfs(1)-1&lt;&lt;endl;    return 0;&#125;</code></pre><p>模拟</p><pre><code>#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;bool visit[2021] = &#123; true &#125;;int main()&#123;    queue&lt;int&gt;cs;    cs.push(2021);    int time = 0;    while (!cs.empty())    &#123;        int size = cs.size();        while (size-- &gt; 0)        &#123;            int cur = cs.front();            cs.pop();            if (cur == 1)            &#123;                cout &lt;&lt; time;                return 0;            &#125;            if (!visit[cur + 1])            &#123;                visit[cur + 1] = true;                cs.push(cur + 1);            &#125;            if (!visit[cur - 1])            &#123;                visit[cur - 1] = true;                cs.push(cur - 1);            &#125;            if (cur % 2 == 0 &amp;&amp; !visit[cur / 2])            &#123;                visit[cur / 2] = true;                cs.push(cur / 2);            &#125;        &#125;        time++;    &#125;    return 0;&#125;</code></pre><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123;    int n;    cin &gt;&gt; n;    vector&lt;vector&lt;int&gt; &gt;res(n, vector&lt;int&gt;(n, 0));    int dx[4] = &#123; 0,1,0,-1 &#125;, dy[4] = &#123; 1,0,-1,0 &#125;;    int x = 0, y = 0;    for (int i = 1, d = 0; i &lt;= n * n; i++)    &#123;        res[x][y] = i;        int a = x + dx[d], b = y + dy[d];        if (a &lt; 0 || a == n || b &lt; 0 || b == n || res[a][b])        &#123;            d = (d + 1) % 4;            a = x + dx[d], b = y + dy[d];        &#125;        x = a, y = b;    &#125;    cout &lt;&lt; res[19][19];    return 0;&#125;</code></pre><pre><code>#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123;    int n;    cin &gt;&gt; n;    vector&lt;vector&lt;int&gt; &gt;res(n, vector&lt;int&gt;(n, 0));    int dx[4] = &#123; 0,1,0,-1 &#125;, dy[4] = &#123; 1,0,-1,0 &#125;;    int x = 0, y = 0;    for (int i = 1, d = 0; i &lt;= n * n; i++)    &#123;        res[x][y] = i;        int a = x + dx[d], b = y + dy[d];        if (a &lt; 0 || a == n || b &lt; 0 || b == n || res[a][b])        &#123;            d = (d + 1) % 4;            a = x + dx[d], b = y + dy[d];        &#125;        x = a, y = b;    &#125;    cout &lt;&lt; res[19][19];    return 0;&#125;</code></pre><pre><code>#include&lt;iostream&gt;#include&lt;bits/stdc++.h&gt;typedef  long long LL;using namespace std;const int N=1000000+10;int arr[N];void cal(LL n)&#123;    for(LL i=1;i&lt;=sqrt(n);i++)&#123;        if(n%i==0)&#123;            arr[i]++;            if(n!=i*i)&#123;                arr[n/i]++;            &#125;        &#125;    &#125;&#125;int main()&#123;    LL a,b,c;    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;    cal(a);    cal(b);    cal(c);    int ans=0;    for(int i=0;i&lt;=N;i++)&#123;        if(arr[i]&gt;=2)&#123;            cout&lt;&lt;i&lt;&lt;&#39; &#39;;            ans++;        &#125;    &#125;    cout&lt;&lt;endl;    cout&lt;&lt;ans&lt;&lt;endl; &#125; </code></pre><pre><code>#include&lt;iostream&gt;#include&lt;bits/stdc++.h&gt;using namespace std;char a[105][105],b[105][105];int n,m,r,c;bool check(int x,int y)&#123;    for(int i=0;i&lt;r;i++)    &#123;        for(int j=0;j&lt;c;j++)&#123;            if(b[i][j]==&#39;1&#39;&amp;&amp;a[x+i][y+j]==&#39;1&#39;||b[i][j]==&#39;0&#39;)            continue;            else return false;        &#125;    &#125;    return true;    &#125;int main()&#123;    int flag=0;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)    cin&gt;&gt;a[i];        cin&gt;&gt;r&gt;&gt;c;    for(int i=0;i&lt;r;i++)    cin&gt;&gt;b[i];    if(r&gt;n||r&gt;m||c&gt;m||c&gt;n)    &#123;        cout&lt;&lt;&quot;NO&quot;;        return 0;    &#125;    for(int i=0;i&lt;=n-r;i++)    for(int j=0;j&lt;=m-c;j++)&#123;        if(check(i,j))&#123;            cout&lt;&lt;i+1&lt;&lt;&quot; &quot;&lt;&lt;j+1;            return 0;        &#125;    &#125;    if(!flag)cout&lt;&lt;&quot;NO&quot;;    return 0;&#125;</code></pre><pre><code>#include&lt;iostream&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int N=20;char ans[N];int main()&#123;    string s;    cin&gt;&gt;s;    int idx=0;        for(int i=0;s[i];i++)&#123;        if(s[i]!=&#39;,&#39;)&#123;            ans[idx++]=s[i];        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;    return 0;&#125;</code></pre><p>先赋值再++</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/08/%E5%AE%9E%E4%B9%A0%E4%BA%8C%20%E5%8F%82%E7%85%A7%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/05/08/%E5%AE%9E%E4%B9%A0%E4%BA%8C%20%E5%8F%82%E7%85%A7%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>实习二 参照博客</p><pre><code>https://www.writebug.com/git/Badguy/sudoku-game   Qt https://m.bilibili.com/video/av891293761 视频解释https://zhuanlan.zhihu.com/p/69737736  知乎 python </code></pre><p>路线</p><pre><code>1、把数独问题转换为精确覆盖问题   √2、设计出数据矩阵                3、用舞蹈链（Dancing Links）算法求解该精确覆盖问题4、把该精确覆盖问题的解转换为数独的解</code></pre><pre><code>约束条件：阵的每个列都定义成一个约束条件1、每个格子只能填一个数字2、每行1-9的这9个数字都得填一遍（也就意味着每个数字只能填一遍）3、每列1-9的这9个数字都得填一遍4、每宫1-9的这9个数字都得填一遍</code></pre><pre><code>那接下来，就是把数独转换为矩阵数独问题中，每个格子分两种情况。有数字的格子、没数字的格子。</code></pre><pre><code>有数字的格子以例子来说明，在（4，2）中填的是7把（4，2）中填的是7，解释成4个约束条件1、在（4，2）中填了一个数字。2、在第4行填了数字73、在第2列填了数字74、在第4宫填了数字7（坐标（X，Y）到宫N的公式为：N=INT（（X-1）/3）×3+INT（（Y-1）/3）+1） 那么这4个条件，分别转换成矩阵对应的列为1、在（4，2）中填了一个数字。对应的列N=（4-1）×9+2=292、在第4行填了数字7。对应的列N=（4-1）×9+7+81=1153、在第2列填了数字7。对应的列N=（2-1）×9+7+162=1784、在第4宫填了数字7。对应的列N=（4-1）×9+7+243=277 于是，（4，2）中填的是7，转成矩阵的一行就是，第29、115、178、277列是1，其余列是0。把这1行插入到矩阵中去。————————————————版权声明：本文为CSDN博主「PeterBishop0」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_40061421/article/details/85677346</code></pre><pre><code>init(); //初始化change();//每一步的改变   更新矩阵show();//显示，刷新输出re_last();//返回到上次  change的值要保存  50步撤销  栈堆cun&#39;shagain();//重构</code></pre><pre><code>棋盘所需initclearnew 新建check 检测checkVal  值？finished 查完全</code></pre><p>先复刻 再改值</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/08/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9A%82%E5%AD%98/"/>
      <url>/2022/05/08/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9A%82%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code> if(Busy_Count&gt;2)    &#123;         checkBusyT-&gt;stop();         //弹出内容         QSystemTrayIcon* tmptrayIcon = new QSystemTrayIcon(this);                                   //设置菜单         tmptrayIcon-&gt;show();//         QObject::connect(tmptrayIcon,SIGNAL(activated(QSystemTrayIcon::ActivationReason)),this,SLOT(TrayIconAction(QSystemTrayIcon::ActivationReason)));//连接信号与槽，实现单击图标恢复窗口的功能，槽是自定义的槽         tmptrayIcon-&gt;showMessage(tr(&quot;勿扰中止&quot;), tr(&quot;请调整学习状态&quot;), QSystemTrayIcon::Information, 1000);    &#125;</code></pre><pre><code>【用户故事（User Story）】作为 一个正在自习室学习的大学生 我希望 能够专注于学习，尽可能减少对手机的使用以便 提高学习效率，完成自己规划的任务【验收标准】1、勿扰模式下不能接收各类消息2、可以手动结束，但是会再次弹窗询问确定与否3、在背景和音乐的处理上，尽可能让人平静</code></pre><pre><code>【用户故事（User Story）】作为 一个正在自习室学习的大学生 我希望 能够专注于学习，尽可能减少对手机的使用以便 提高学习效率，完成自己规划的任务【验收标准】1、勿扰模式下不能接收各类消息2、可以手动结束，但是会再次弹窗询问确定与否3、在背景和音乐的处理上，尽可能让人平静</code></pre><pre><code>【用户故事（User Story）】作为 一个正在自习室学习的大学生 我希望 能够专注于学习，尽可能减少对手机的使用以便 提高学习效率，完成自己规划的任务【验收标准】1、勿扰模式下不能接收各类消息2、可以手动结束，但是会再次弹窗询问确定与否3、在背景和音乐的处理上，尽可能让人平静</code></pre><pre><code></code></pre><p><img src="C:\Users\15818\AppData\Roaming\Typora\typora-user-images\image-20220415163946908.png" alt="image-20220415163946908"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/08/0421colab%E8%AE%AD%E7%BB%83%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/05/08/0421colab%E8%AE%AD%E7%BB%83%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>!CUDA_VISIBLE_DEVICES=0 python trainval_net.py \</p><p>​          –dataset pascal_voc \</p><p>​          –net vgg16 \</p><p>​          –bs 4 \</p><p>​          –nw 0 \</p><p>​          –lr 0.004 \</p><p>​          –lr_decay_step 8 \</p><p>​          –epochs 9 \</p><p>​          –cuda –r true –checksession 1 –checkepoch 1 –checkpoint 2504</p><pre><code>!CUDA_VISIBLE_DEVICES=0 python trainval_net.py \                    --dataset pascal_voc \                    --net vgg16 \                    --bs 4 \                    --nw 0 \                    --lr 0.004 \                    --lr_decay_step 8 \                    --epochs 9 \                    --cuda --r true --checksession 1 --checkepoch 1 --checkpoint 2504</code></pre><pre><code>!CUDA_VISIBLE_DEVICES=0 python trainval_net.py \                    --dataset pascal_voc \                    --net vgg16 \                    --bs 4 \                    --nw 0 \                    --lr 0.004 \                    --lr_decay_step 8 \                    --epochs 9 \                    --cuda --r true --checksession 1 --checkepoch 1 --checkpoint 2504 </code></pre><p>data 下 cache</p><pre><code>Called with args:Namespace(batch_size=4, checkepoch=1, checkpoint=2504, checkpoint_interval=10000, checksession=1, class_agnostic=False, cuda=True, dataset=&#39;pascal_voc&#39;, disp_interval=100, large_scale=False, lr=0.004, lr_decay_gamma=0.1, lr_decay_step=8, mGPUs=False, max_epochs=9, net=&#39;vgg16&#39;, num_workers=0, optimizer=&#39;sgd&#39;, resume=True, save_dir=&#39;models&#39;, session=1, start_epoch=1, use_tfboard=False)Using config:&#123;&#39;ANCHOR_RATIOS&#39;: [0.5, 1, 2], &#39;ANCHOR_SCALES&#39;: [8, 16, 32], &#39;CROP_RESIZE_WITH_MAX_POOL&#39;: False, &#39;CUDA&#39;: False, &#39;DATA_DIR&#39;: &#39;/content/drive/MyDrive/faster-rcnn.pytorch/data&#39;, &#39;DEDUP_BOXES&#39;: 0.0625, &#39;EPS&#39;: 1e-14, &#39;EXP_DIR&#39;: &#39;vgg16&#39;, &#39;FEAT_STRIDE&#39;: [16], &#39;GPU_ID&#39;: 0, &#39;MATLAB&#39;: &#39;matlab&#39;, &#39;MAX_NUM_GT_BOXES&#39;: 20, &#39;MOBILENET&#39;: &#123;&#39;DEPTH_MULTIPLIER&#39;: 1.0,               &#39;FIXED_LAYERS&#39;: 5,               &#39;REGU_DEPTH&#39;: False,               &#39;WEIGHT_DECAY&#39;: 4e-05&#125;, &#39;PIXEL_MEANS&#39;: array([[[102.9801, 115.9465, 122.7717]]]), &#39;POOLING_MODE&#39;: &#39;align&#39;, &#39;POOLING_SIZE&#39;: 7, &#39;RESNET&#39;: &#123;&#39;FIXED_BLOCKS&#39;: 1, &#39;MAX_POOL&#39;: False&#125;, &#39;RNG_SEED&#39;: 3, &#39;ROOT_DIR&#39;: &#39;/content/drive/MyDrive/faster-rcnn.pytorch&#39;, &#39;TEST&#39;: &#123;&#39;BBOX_REG&#39;: True,          &#39;HAS_RPN&#39;: True,          &#39;MAX_SIZE&#39;: 1000,          &#39;MODE&#39;: &#39;nms&#39;,          &#39;NMS&#39;: 0.3,          &#39;PROPOSAL_METHOD&#39;: &#39;gt&#39;,          &#39;RPN_MIN_SIZE&#39;: 16,          &#39;RPN_NMS_THRESH&#39;: 0.7,          &#39;RPN_POST_NMS_TOP_N&#39;: 300,          &#39;RPN_PRE_NMS_TOP_N&#39;: 6000,          &#39;RPN_TOP_N&#39;: 5000,          &#39;SCALES&#39;: [600],          &#39;SVM&#39;: False&#125;, &#39;TRAIN&#39;: &#123;&#39;ASPECT_GROUPING&#39;: False,           &#39;BATCH_SIZE&#39;: 256,           &#39;BBOX_INSIDE_WEIGHTS&#39;: [1.0, 1.0, 1.0, 1.0],           &#39;BBOX_NORMALIZE_MEANS&#39;: [0.0, 0.0, 0.0, 0.0],           &#39;BBOX_NORMALIZE_STDS&#39;: [0.1, 0.1, 0.2, 0.2],           &#39;BBOX_NORMALIZE_TARGETS&#39;: True,           &#39;BBOX_NORMALIZE_TARGETS_PRECOMPUTED&#39;: True,           &#39;BBOX_REG&#39;: True,           &#39;BBOX_THRESH&#39;: 0.5,           &#39;BG_THRESH_HI&#39;: 0.5,           &#39;BG_THRESH_LO&#39;: 0.0,           &#39;BIAS_DECAY&#39;: False,           &#39;BN_TRAIN&#39;: False,           &#39;DISPLAY&#39;: 10,           &#39;DOUBLE_BIAS&#39;: True,           &#39;FG_FRACTION&#39;: 0.25,           &#39;FG_THRESH&#39;: 0.5,           &#39;GAMMA&#39;: 0.1,           &#39;HAS_RPN&#39;: True,           &#39;IMS_PER_BATCH&#39;: 1,           &#39;LEARNING_RATE&#39;: 0.01,           &#39;MAX_SIZE&#39;: 1000,           &#39;MOMENTUM&#39;: 0.9,           &#39;PROPOSAL_METHOD&#39;: &#39;gt&#39;,           &#39;RPN_BATCHSIZE&#39;: 256,           &#39;RPN_BBOX_INSIDE_WEIGHTS&#39;: [1.0, 1.0, 1.0, 1.0],           &#39;RPN_CLOBBER_POSITIVES&#39;: False,           &#39;RPN_FG_FRACTION&#39;: 0.5,           &#39;RPN_MIN_SIZE&#39;: 8,           &#39;RPN_NEGATIVE_OVERLAP&#39;: 0.3,           &#39;RPN_NMS_THRESH&#39;: 0.7,           &#39;RPN_POSITIVE_OVERLAP&#39;: 0.7,           &#39;RPN_POSITIVE_WEIGHT&#39;: -1.0,           &#39;RPN_POST_NMS_TOP_N&#39;: 2000,           &#39;RPN_PRE_NMS_TOP_N&#39;: 12000,           &#39;SCALES&#39;: [600],           &#39;SNAPSHOT_ITERS&#39;: 5000,           &#39;SNAPSHOT_KEPT&#39;: 3,           &#39;SNAPSHOT_PREFIX&#39;: &#39;res101_faster_rcnn&#39;,           &#39;STEPSIZE&#39;: [30000],           &#39;SUMMARY_INTERVAL&#39;: 180,           &#39;TRIM_HEIGHT&#39;: 600,           &#39;TRIM_WIDTH&#39;: 600,           &#39;TRUNCATED&#39;: False,           &#39;USE_ALL_GT&#39;: True,           &#39;USE_FLIPPED&#39;: True,           &#39;USE_GT&#39;: False,           &#39;WEIGHT_DECAY&#39;: 0.0005&#125;, &#39;USE_GPU_NMS&#39;: True&#125;Loaded dataset `voc_2007_trainval` for trainingSet proposal method: gtAppending horizontally-flipped training examples...Traceback (most recent call last):  File &quot;trainval_net.py&quot;, line 197, in &lt;module&gt;    imdb, roidb, ratio_list, ratio_index = combined_roidb(args.imdb_name)  File &quot;/content/drive/MyDrive/faster-rcnn.pytorch/lib/roi_data_layer/roidb.py&quot;, line 116, in combined_roidb    roidbs = [get_roidb(s) for s in imdb_names.split(&#39;+&#39;)]  File &quot;/content/drive/MyDrive/faster-rcnn.pytorch/lib/roi_data_layer/roidb.py&quot;, line 116, in &lt;listcomp&gt;    roidbs = [get_roidb(s) for s in imdb_names.split(&#39;+&#39;)]  File &quot;/content/drive/MyDrive/faster-rcnn.pytorch/lib/roi_data_layer/roidb.py&quot;, line 113, in get_roidb    roidb = get_training_roidb(imdb)  File &quot;/content/drive/MyDrive/faster-rcnn.pytorch/lib/roi_data_layer/roidb.py&quot;, line 97, in get_training_roidb    imdb.append_flipped_images()  File &quot;/content/drive/MyDrive/faster-rcnn.pytorch/lib/datasets/imdb.py&quot;, line 118, in append_flipped_images    boxes = self.roidb[i][&#39;boxes&#39;].copy()  File &quot;/content/drive/MyDrive/faster-rcnn.pytorch/lib/datasets/imdb.py&quot;, line 76, in roidb    self._roidb = self.roidb_handler()  File &quot;/content/drive/MyDrive/faster-rcnn.pytorch/lib/datasets/pascal_voc.py&quot;, line 132, in gt_roidb    for index in self.image_index]  File &quot;/content/drive/MyDrive/faster-rcnn.pytorch/lib/datasets/pascal_voc.py&quot;, line 132, in &lt;listcomp&gt;    for index in self.image_index]  File &quot;/content/drive/MyDrive/faster-rcnn.pytorch/lib/datasets/pascal_voc.py&quot;, line 211, in _load_pascal_annotation    tree = ET.parse(filename)  File &quot;/usr/lib/python3.7/xml/etree/ElementTree.py&quot;, line 1197, in parse    tree.parse(source, parser)  File &quot;/usr/lib/python3.7/xml/etree/ElementTree.py&quot;, line 598, in parse    self._root = parser._parse_whole(source)KeyboardInterrupt</code></pre><pre><code>File &quot;trainval_net.py&quot;, line 197, in &lt;module&gt;    imdb, roidb, ratio_list, ratio_index = combined_roidb(args.imdb_name)  File &quot;/content/drive/MyDrive/faster-rcnn.pytorch/lib/roi_data_layer/roidb.py&quot;, line 116, in combined_roidb    roidbs = [get_roidb(s) for s in imdb_names.split(&#39;+&#39;)]  File &quot;/content/drive/MyDrive/faster-rcnn.pytorch/lib/roi_data_layer/roidb.py&quot;, line 116, in &lt;listcomp&gt;    roidbs = [get_roidb(s) for s in imdb_names.split(&#39;+&#39;)]  File &quot;/content/drive/MyDrive/faster-rcnn.pytorch/lib/roi_data_layer/roidb.py&quot;, line 113, in get_roidb    roidb = get_training_roidb(imdb)  File &quot;/content/drive/MyDrive/faster-rcnn.pytorch/lib/roi_data_layer/roidb.py&quot;, line 97, in get_training_roidb    imdb.append_flipped_images()  File &quot;/content/drive/MyDrive/faster-rcnn.pytorch/lib/datasets/imdb.py&quot;, line 116, in append_flipped_images    widths = self._get_widths()  File &quot;/content/drive/MyDrive/faster-rcnn.pytorch/lib/datasets/imdb.py&quot;, line 112, in _get_widths    for i in range(self.num_images)]  File &quot;/content/drive/MyDrive/faster-rcnn.pytorch/lib/datasets/imdb.py&quot;, line 112, in &lt;listcomp&gt;    for i in range(self.num_images)]</code></pre><p>视频学习 效果   </p><p>4月 给出一个讨论的结果 在4月底之前 对视频检测跑一个结果出来</p><p>动态视频特征   目标动作行为语义</p><p>人走在路上 突然闯入  异常行为  </p><p>路口有一个车 </p><p>人群里闯入一个车   游戏里模拟  </p><p>用同样的数据检测一种异常   调参 参数   UCF sprot</p><pre><code>!CUDA_VISIBLE_DEVICES=0 python trainval_net.py --dataset pascal_voc --net vgg16 --bs 1 --nw 4  --cuda --r true --checksession 1 --checkepoch 1 --checkpoint 2504 --epochs 5</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/08/%E6%9D%82%E9%A1%B9/"/>
      <url>/2022/05/08/%E6%9D%82%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数独 auto按钮对应事件有问题</p><p>数独 初始化棋局 差别同源代码差异大</p><p>操作系统第二题 </p><p>发出请求后值未发生变化</p><p>第三题</p><p>小块 大块</p><p>连续</p><p>找到要删除的地方 变成hole</p><pre><code>#ifndef BLOCK_H#define BLOCK_H#include&lt;iostream&gt;#include&lt;process.h&gt;#include &lt;memory.h&gt;#include&lt;memory&gt;#include&lt;stdio.h&gt;using namespace std;struct BlockNode &#123;    char val;  // 程序名    BlockNode* next;  // 指向下一个节点的指针    BlockNode();    BlockNode(int x) : val(x), next(NULL) &#123;&#125;  // 节点的构造函数    int size;//内存块大小    int pos;//起始位置&#125;;class BlockList &#123;public:    BlockList() &#123;        first = NULL;    &#125;    void init( int tmp);//初始化    void assign(BlockNode* q, char val, int size);    int ff(int tmp,char val,int size);    int bf(int tmp, char val, int size);    int wf(int tmp,char val,int size);    void f_assign(int tmp);    void Main( int tmp);    void showState();//查看内存状态    int  releaseSource(int tmp,char val,int size);//撤销进程，释放资源private:    BlockNode* first;    BlockNode* p;&#125;;BlockNode* base;int main()&#123;    char choice;    int tmp;    BlockList cs;    while (1)    &#123;        system(&quot;cls&quot;);        cout &lt;&lt; &quot;演示&quot; &lt;&lt;endl ;        cout &lt;&lt; &quot;1.静态分配 2.动态分配 3 退出程序&quot; &lt;&lt; endl;        cin &gt;&gt; choice;        if (choice == &#39;1&#39;)tmp = 0;        else if (choice == &#39;2&#39;)tmp = 1;        else if (choice == &#39;3&#39;)break;        cs.Main(tmp);    &#125;    return 0;&#125;void BlockList::init( int tmp)&#123;    BlockNode* p, * q;    if (base != NULL)    &#123;        p = base;        while (p)        &#123;            q = p-&gt;next;            delete p;            p = q;        &#125;    &#125;    base = new BlockNode;//操作系统 大小24k    base-&gt;pos = 0;    base-&gt;val = &#39;o&#39;;//代表操作系统    base-&gt;size = 4;//4k    if (tmp == 0)//静态处理    &#123;        //1        p = base;        q = new BlockNode;        q-&gt;pos = 4;        q-&gt;val = 0;        q-&gt;size = 20;        p-&gt;next = q;        p = q;        //2        q = new BlockNode;        q-&gt;pos = 24;        q-&gt;val = 0;        q-&gt;size = 40;        p-&gt;next = q;        p = q;        //3        q = new BlockNode;        q-&gt;pos = 64;        q-&gt;val = 0;        q-&gt;size = 50;        p-&gt;next = q;        p = q;        //4        q = new BlockNode;        q-&gt;pos = 124;        q-&gt;val = 0;        q-&gt;size = 30;        p-&gt;next = q;        p = q;        //5        q = new BlockNode;        q-&gt;pos = 154;        q-&gt;val = 0;        q-&gt;size = 16;        p-&gt;next = q;        p = q;    &#125;    else    &#123;        p = new BlockNode;        p-&gt;pos = 0;        p-&gt;size = 30;        p-&gt;next = NULL;        base-&gt;next = p;    &#125;&#125;void BlockList::assign(BlockNode* q, char val, int size)&#123;    //q 待检测的块    BlockNode* p = q-&gt;next;    BlockNode* temp = new BlockNode;    temp = new BlockNode;    temp-&gt;pos = p-&gt;pos;    temp-&gt;size = p-&gt;size;    q-&gt;next = temp;    if (p-&gt;size &lt; size)    &#123;        p-&gt;size = p-&gt;size - size;        p-&gt;pos = temp-&gt;pos + temp-&gt;size;        temp-&gt;next = p;    &#125;    else if(p-&gt;size=size)    &#123;        temp-&gt;next = p-&gt;next;        delete p;    &#125;    else    &#123;        cout &lt;&lt; &quot;无法分配！该块空间不足！&quot;;    &#125;&#125;int BlockList::ff(int tmp, char val, int size)&#123;    BlockNode* p = base;    BlockNode* q = p;    while (p)    &#123;        if (p-&gt;size &lt; size || p-&gt;val != 0)        &#123;            q = p;            p = p-&gt;next;        &#125;        else break;    &#125;    if (p == NULL)return 0;//未找到    else    &#123;        if (tmp == 0)p-&gt;val = val;//进程进驻内存        else assign(q, val, size);    &#125;    return 1;//返回1&#125;int BlockList::bf(int tmp, char val, int size)&#123;    BlockNode* p = base, * temp = NULL, * q = NULL, * front = NULL;    int min = 256;    while (p)    &#123;        if (p-&gt;val == 0 &amp;&amp; p-&gt;size &gt;= size &amp;&amp; min&gt;p-&gt;size)        &#123;            min = p-&gt;size;//更新最小值            front = q;            temp = p;        &#125;        q = p;        p = p-&gt;next;    &#125;    if (temp == NULL)return 0;//    else    &#123;        if (tmp == 0)temp-&gt;val = val;//静态进驻        else assign(front, val, size);    &#125;    return 1;&#125;int BlockList::wf(int tmp, char val, int size)&#123;    BlockNode* p = base, * temp = NULL, * q = NULL, * front = NULL;    int max = 0;    while (p)    &#123;        if (p-&gt;val == 0 &amp;&amp; p-&gt;size &gt;= size &amp;&amp; max &lt; p-&gt;size)        &#123;            max = p-&gt;size;//更新最小值            front = q;            temp = p;        &#125;        q = p;        p = p-&gt;next;    &#125;    if (temp == NULL)return 0;//    else    &#123;        if (tmp == 0)temp-&gt;val = val;//静态进驻        else assign(front, val, size);    &#125;    return 1;&#125;void BlockList::f_assign(int tmp)&#123;    int size, result = -1;    char chose, val;    cout &lt;&lt; &quot;请输入进程名:&quot;;    cin &gt;&gt; val;    cout &lt;&lt; &quot;请输入进程分配内存的大小：&quot;;    cin &gt;&gt; size;    cout &lt;&lt; &quot;请选择分配算法：1.首次 2 最佳 3 最差&quot; &lt;&lt; endl;    cin &gt;&gt; chose;    switch (chose)    &#123;    case &#39;1&#39;:        result = ff(chose, val, size);        break;    case &#39;2&#39;:        result = bf(chose, val, size);        break;    case &#39;3&#39;:        result = wf(chose, val, size);        break;    &#125;    if (result == 0)cout &lt;&lt; &quot;进程&quot; &lt;&lt; val &lt;&lt; &quot;分配失败！&quot; &lt;&lt; endl;    else if (result == 1)cout &lt;&lt; &quot;进程&quot; &lt;&lt; val &lt;&lt; &quot;分配成功！&quot; &lt;&lt; endl;    else cout &lt;&lt; &quot;非法输入！&quot; &lt;&lt; endl;&#125;void BlockList::Main(int tmp)&#123;    char choice;    init(tmp);    while (1)    &#123;        system(&quot;cls&quot;);        if (tmp == 0)cout &lt;&lt; &quot;\t\t\t静态分配&quot; &lt;&lt; endl;        else cout &lt;&lt; &quot;\t\t\t 动态分配&quot; &lt;&lt; endl;        showState();        cout &lt;&lt; &quot;请选择操作： \b 1.建立进程并分配&quot; &lt;&lt; endl;        cin &gt;&gt; choice;        if (choice == &#39;1&#39;)        &#123;            f_assign(tmp);            system(&quot;pause&quot;);        &#125;    &#125;&#125;void BlockList::showState()&#123;    BlockNode* p = base;    int count = 1;    cout &lt;&lt; &quot;内存储存情况是：&quot; &lt;&lt; endl;    //printf_s(&quot;块号\t 内容\t\t 大小\t 起始-结束地址\n&quot;);    while (p)    &#123;        /*printf_s(&quot; %2d  &quot;, count++);        printf(p-&gt;val, p-&gt;pos, p-&gt;size);*/        cout &lt;&lt; &quot;块号\t&quot; &lt;&lt; count &lt;&lt; &quot;内容\t\t&quot; &lt;&lt; p-&gt;val &lt;&lt; &quot;大小 \t &quot; &lt;&lt; p-&gt;size &lt;&lt; &quot; 起始-结束地址\n&quot;;        p = p-&gt;next;    &#125;&#125;int BlockList::releaseSource(int tmp, char val, int size)&#123;    BlockNode* p = base, * q = NULL;    while (p)    &#123;        if (p-&gt;val != val)        &#123;            q = p;            p = p-&gt;next;        &#125;        else break;    &#125;    if (p == NULL) return 0;//未找到    //q  p    else    &#123;        if (tmp == 0)p-&gt;val = 0;        else        &#123;            if (q-&gt;val!= 0)            &#123;    //1 前非 后非                if (p-&gt;next != NULL || p-&gt;next-&gt;val != 0)                &#123;                    p-&gt;val = 0;                &#125;                //2 前非 后空                else                &#123;                    q-&gt;next = p-&gt;next;                    p-&gt;next-&gt;pos = p-&gt;pos;                    p-&gt;next-&gt;size = p-&gt;size +p-&gt;next-&gt;size;                    delete p;                &#125;            &#125;            else            &#123;   //3 前空 后非                if (p-&gt;next == NULL || p-&gt;next-&gt;val != 0)                &#123;                    q-&gt;next = p-&gt;next;                    q-&gt;size = q-&gt;size + p-&gt;size;                    delete p;                &#125;                //4 前空 后空                else                &#123;                    q-&gt;next = p-&gt;next-&gt;next;                    q-&gt;size = q-&gt;size + p-&gt;size+p-&gt;next-&gt;size;                    delete p;                    delete p-&gt;next;                &#125;            &#125;        &#125;    &#125;    return 1;&#125;#endif // BLOCK_H</code></pre><pre><code>活动目的：1、让学生认识到时间的重要性，树立珍惜时间的思想意识。 2、培养学生的时间观念，掌握时间管理的基本方法。 3、提高大学生珍惜时间、利用时间的能力。活动具体实施方案介绍：（一）前期工作1.班级同学讨论确定班会主题2.征集班会素材3.提前租用学二组团活动室4.开始前半小时布置会场，调试仪器，保证其能正常使用5.安排班委负责拍照6.通知学生按时到场7.准备好ppt和班会讲解材料（二）活动内容1. 来给时间排个序选取入学至大二下为止的具有代表性的六张照片或截图，抽选同学为按照事件的发生顺序排序，勾起同学的回忆。照片涵盖内容：军训剪影、“大地之光”剧照、“地大隧道”、“众志成城，抗击疫情”剪影。2.时间的歌声里选取五段音频(校内生活常常能听到具有代表性)，抽选同学回答音频播放时对应的场景。音频包含：《勘探队员之歌》(校歌)、《光荣啊，中国共青团》（团歌）、《Going Home》(图书馆闭馆，教学楼闭楼所放歌曲)、《Only Time》（早操预备铃声）。这个活动作为暖身活动，用以活跃课堂气氛，提高同学们参与的积极性。3.“一分钟我们可以做什么”我们先来感受一下一分钟有多长。大家听我喊“开始”就闭眼，单脚站立，静听嘀哒声，一分钟 后我喊“停”再睁开眼睛。大家觉得这一分钟长吗？平时有这么长吗？ 1、    每次活动具体实施方案介绍；2、    班级成员对班级主题活动的评价及建议；3、    相关支撑材料，如活动现场照片、通讯报道、会议记录等。</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A02/"/>
      <url>/2022/05/08/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>操作系统复习</p><p>LRU 最近未使用</p><p>操作系统以扇区为单位对磁盘进行读/写操作</p><p>在操作系统中,FCB是指 文件控制块</p><p>磁带、磁盘这样的存储设备都是以块为单位与内存进行信息交换的。</p><p>在UNIX系统中，磁盘空闲空间管理所采用的方法是（）</p><p>空闲块成组链接法</p><p>逻辑文件是从用户观点看的文件组织形式</p><p>位示图可用于磁盘空间的管理</p><p>设文件索引结点中有8个地址项，每个地址项大小为4字节，其中5个地址项为直接地址索引，2个地址项是一级间接地址索引，1个地址项是二级间接地址索引，磁盘索引块和磁盘数据块大小均为1KB。则可表示的单个文件最大长度是多少KB？</p><p>解：磁盘索引块为1KB字节，每个地址项大小为4字节，故每个磁盘索引块可存放1024/4=256个物理地址块。又因为文件索引节点中有8个地址项，其中5个地址项为直接地址索引，这意味着逻辑块号为0—4的为直接地址索引；2个地址项是一级间接地址索引，这意味着第一个地址项指出的物理块中存放逻辑块号为5—260的物理块号，第二个地址项指出的物理块中存放逻辑块号为261—516的物理块号；1个地址项是二级间接地址索引，该地址项指出的物理块存放了256个间接索引表的地址，这256个间接索引表存放逻辑块号为517—66052的物理块号（256*256=65536个）。单个文件的逻辑块号范围是0—66052，而磁盘数据块大小为1KB，所以单个文件最大长度为：66053KB。<br>————————————————<br>版权声明：本文为CSDN博主「Mrchai521」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p><p><strong>独占设备。<strong><strong>任一指定的时刻</strong></strong>只能让一个****进程使用的设备。如</strong></p><p><strong>打印机、磁带驱动器等</strong></p><p>采用直接存取方法来读写磁盘上的物理记录时，效率最低的文件结构是连续文件</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/05/08/colab%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2022/05/08/colab%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><pre><code>import osos.chdir(&#39;/content/drive/MyDrive/faster-rcnn.pytorch&#39;)!pip install scipy==1.2.1</code></pre><pre><code>!python demo.py --net vgg16  --checksession 1  --checkepoch 1 --checkpoint 2504 --cuda --load_dir models</code></pre><pre><code>import osos.chdir(&#39;/content/drive/MyDrive/faster-rcnn.pytorch/lib&#39;)!python setup.py build develop</code></pre><pre><code>!python setup.py build develop</code></pre><pre><code>!apt-get install -y -qq software-properties-common python-software-properties module-init-tools!add-apt-repository -y ppa:alessandro-strada/ppa 2&gt;&amp;1 &gt; /dev/null!apt-get update -qq 2&gt;&amp;1 &gt; /dev/null!apt-get -y install -qq google-drive-ocamlfuse fusefrom google.colab import authauth.authenticate_user()from oauth2client.client import GoogleCredentialscreds = GoogleCredentials.get_application_default()import getpass!google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125; &lt; /dev/null 2&gt;&amp;1 | grep URLvcode = getpass.getpass()!echo &#123;vcode&#125; | google-drive-ocamlfuse -headless -id=&#123;creds.client_id&#125; -secret=&#123;creds.client_secret&#125;</code></pre><pre><code>!pip install torch==1.5.0 torchvision</code></pre><p>jwyang fasterrcnn 基于pytorch</p><p>另一路 tensenflow</p><pre><code>ERROR: pip&#39;s dependency resolver does not currently take into account all the packages that are installed. This behaviour is the source of the following dependency conflicts.torchtext 0.12.0 requires torch==1.11.0, but you have torch 1.5.0 which is incompatible.torchaudio 0.11.0+cu113 requires torch==1.11.0, but you have torch 1.5.0 which is incompatible.</code></pre><pre><code>间隔多少时间框是否同一个实体另外一份代码数据集调换数据集 测量传入异常 作为输入代码调通 s</code></pre><p>降级pytorch1.4</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ceshi</title>
      <link href="/2021/09/20/ceshi/"/>
      <url>/2021/09/20/ceshi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>title: ceshi<br>date: 2021-09-20 11:08:34<br>categories:<br>tags:</p><p>andakdad</p><p>中文</p><p>可以了啊</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++输入输出流</title>
      <link href="/2021/05/06/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
      <url>/2021/05/06/C-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>1720-解码异或后的数组</title>
      <link href="/2021/05/06/1720-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84/"/>
      <url>/2021/05/06/1720-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1720-解码异或后的数组"><a href="#1720-解码异或后的数组" class="headerlink" title="1720. 解码异或后的数组"></a><a href="https://leetcode-cn.com/problems/decode-xored-array/">1720. 解码异或后的数组</a></h4><h1 id="异或-性质-a-b"><a href="#异或-性质-a-b" class="headerlink" title="异或^性质(a^b)"></a>异或^性质(a^b)</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><blockquote><p>a^a=0,a^0=a    //针对位数</p></blockquote><h2 id="2-交换律·"><a href="#2-交换律·" class="headerlink" title="2.交换律·"></a>2.交换律·</h2><blockquote><p>a^b = b^a</p></blockquote><h3 id="3-结合律"><a href="#3-结合律" class="headerlink" title="3.结合律"></a>3.结合律</h3><blockquote><p>(a^b)^c=a^(b^c)</p></blockquote><h3 id="4-衍生-”-“"><a href="#4-衍生-”-“" class="headerlink" title="4.衍生-”==“"></a>4.衍生-”==“</h3><blockquote><p>a^c==b^c</p><p>a==b</p></blockquote><h3 id="5-swap函数原理"><a href="#5-swap函数原理" class="headerlink" title="5.swap函数原理"></a>5.swap函数原理</h3><pre><code class="c++">void swap (int a int b)&#123;    //a =2 b=1a=a^b;//(1)a 10   b 01b=a^b;//(2)a 11  b10a=a^b;//(3)a 01&#125;</code></pre><hr><h3 id="答案↓"><a href="#答案↓" class="headerlink" title="答案↓"></a>答案↓</h3><h4 id="C-版本"><a href="#C-版本" class="headerlink" title="C++版本"></a>C++版本</h4><pre><code class="c++">class Solution &#123;public:    vector&lt;int&gt; decode(vector&lt;int&gt;&amp; encoded, int first)     &#123;         vector&lt;int&gt;ans;            ans.push_back(first);            for(int i=0;i&lt;encoded.size();i++)                ans.push_back(ans.back()^encoded[i]);            return ans;    &#125;&#125;;</code></pre><h4 id="Python3版本"><a href="#Python3版本" class="headerlink" title="Python3版本"></a>Python3版本</h4><pre><code class="Python3">class Solution:    def decode(self, encoded: List[int], first: int) -&gt; List[int]:        res = [first]        for e in encoded:            res.append(res[-1] ^ e)        retur</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/05/04/hello-world/"/>
      <url>/2021/05/04/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p>ll</p><p>hexo new “第二篇Hexo blog文章”</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
